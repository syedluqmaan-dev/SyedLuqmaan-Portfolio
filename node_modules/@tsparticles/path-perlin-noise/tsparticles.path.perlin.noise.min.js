/*! For license information please see tsparticles.path.perlin.noise.min.js.LICENSE.txt */
!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t(require("@tsparticles/engine"),require("@tsparticles/perlin-noise"));else if("function"==typeof define&&define.amd)define(["@tsparticles/engine","@tsparticles/perlin-noise"],t);else{var o="object"==typeof exports?t(require("@tsparticles/engine"),require("@tsparticles/perlin-noise")):t(e.window,e.window);for(var i in o)("object"==typeof exports?exports:e)[i]=o[i]}}(this,((e,t)=>(()=>{var o={303:t=>{t.exports=e},846:e=>{e.exports=t}},i={};function s(e){var t=i[e];if(void 0!==t)return t.exports;var n=i[e]={exports:{}};return o[e](n,n.exports,s),n.exports}s.d=(e,t)=>{for(var o in t)s.o(t,o)&&!s.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:t[o]})},s.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),s.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};s.r(n),s.d(n,{loadPerlinNoisePath:()=>d,perlinNoisePathName:()=>h});var r=s(303),a=s(846);const l=2*Math.PI,f={draw:!1,size:20,increment:.004,columns:0,rows:0,layers:0,width:0,height:0,factor:{angle:.02,length:.01},offset:{x:4e4,y:4e4,z:4e4}};class c{constructor(){this.noiseGen=new a.PerlinNoise,this.field=[],this.noiseW=0,this.options=(0,r.deepExtend)({},f)}generate(e){const t=e.getPosition(),{size:o}=this.options,i=Math.max(Math.floor(t.x/o),0),s=Math.max(Math.floor(t.y/o),0),n=Math.max(Math.floor(t.z/o),0),a=r.Vector.origin,{field:l}=this;return l?.[i]?.[s]?.[n]?l[i][s][n].copy():a}init(e){this.container=e,this._setup()}reset(){}update(){this.container&&(this._calculateField(),this.noiseW+=this.options.increment,this.options.draw&&this.container.canvas.draw((e=>this._drawField(e))))}_calculateField(){const{field:e,noiseGen:t,options:o,noiseW:i}=this,s=o.factor.length,n=o.factor.angle;for(let r=0;r<o.columns;r++)for(let a=0;a<o.rows;a++)for(let f=0;f<o.layers;f++){const c=e[r][a][f];c.length=t.noise4d(r*s+o.offset.x,a*s+o.offset.y,f*s+o.offset.z,i),c.angle=t.noise4d(r*n,a*n,f*n,i)*l}}_drawField(e){const{field:t,options:o}=this;for(let i=0;i<o.columns;i++){const s=t[i];for(let t=0;t<o.rows;t++){const o=s[t][0],{angle:n,length:r}=o;e.setTransform(1,0,0,1,i*this.options.size,t*this.options.size),e.rotate(n),e.strokeStyle="white",e.beginPath(),e.moveTo(0,0),e.lineTo(0,this.options.size*r),e.stroke(),e.setTransform(1,0,0,1,0,0)}}}_initField(){const{columns:e,rows:t,layers:o}=this.options;this.field=new Array(e);for(let i=0;i<e;i++){this.field[i]=new Array(t);for(let e=0;e<t;e++){this.field[i][e]=new Array(o);for(let t=0;t<o;t++)this.field[i][e][t]=r.Vector.origin}}}_resetField(){const e=this.container;if(!e)return;const t=e.actualOptions.particles.move.path.options,{options:o}=this;o.width=e.canvas.size.width,o.height=e.canvas.size.height,o.size=t.size>0?t.size:f.size,o.increment=t.increment>0?t.increment:f.increment,o.draw=!!t.draw;const i=t.offset;o.offset.x=i?.x??f.offset.x,o.offset.y=i?.y??f.offset.y,o.offset.z=i?.z??f.offset.z;const s=t.factor;o.factor.angle=s?.angle??f.factor.angle,o.factor.length=s?.length??f.factor.length,o.seed=t.seed,this.noiseGen.seed(o.seed??(0,r.getRandom)()),o.columns=Math.floor(o.width/o.size)+1,o.rows=Math.floor(o.height/o.size)+1,o.layers=Math.floor(e.zLayers/o.size)+1,this._initField()}_setup(){this.noiseW=0,this._resetField(),addEventListener("resize",(()=>this._resetField()))}}const h="perlinNoise";async function d(e,t=!0){e.checkVersion("3.9.1"),await e.addPathGenerator(h,new c,t)}return n})()));