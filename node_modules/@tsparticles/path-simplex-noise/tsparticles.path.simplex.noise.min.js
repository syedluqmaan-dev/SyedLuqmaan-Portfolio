/*! For license information please see tsparticles.path.simplex.noise.min.js.LICENSE.txt */
!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t(require("@tsparticles/engine"),require("@tsparticles/simplex-noise"));else if("function"==typeof define&&define.amd)define(["@tsparticles/engine","@tsparticles/simplex-noise"],t);else{var s="object"==typeof exports?t(require("@tsparticles/engine"),require("@tsparticles/simplex-noise")):t(e.window,e.window);for(var o in s)("object"==typeof exports?exports:e)[o]=s[o]}}(this,((e,t)=>(()=>{var s={226:e=>{e.exports=t},303:t=>{t.exports=e}},o={};function i(e){var t=o[e];if(void 0!==t)return t.exports;var n=o[e]={exports:{}};return s[e](n,n.exports,i),n.exports}i.d=(e,t)=>{for(var s in t)i.o(t,s)&&!i.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:t[s]})},i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};i.r(n),i.d(n,{loadSimplexNoisePath:()=>h,simplexNoisePathName:()=>c});var r=i(303),a=i(226);const l={draw:!1,size:20,increment:.004,columns:0,rows:0,layers:0,width:0,height:0,factor:{angle:.02,length:.01},offset:{x:4e4,y:4e4,z:4e4}};class f{constructor(){const e=new a.SimplexNoise;this._simplex=e.noise4d,this.field=[],this.noiseW=0,this.options=(0,r.deepExtend)({},l)}generate(e){const t=e.getPosition(),{size:s}=this.options,o=Math.max(Math.floor(t.x/s),0),i=Math.max(Math.floor(t.y/s),0),n=Math.max(Math.floor(t.z/s),0),a=r.Vector.origin,{field:l}=this;return l?.[o]?.[i]?.[n]?l[o][i][n].copy():a}init(e){this.container=e,this._setup()}reset(){}update(){this.container&&(this._calculateField(),this.noiseW+=this.options.increment,this.options.draw&&this.container.canvas.draw((e=>this._drawField(e))))}_calculateField(){const{options:e,field:t,_simplex:s,noiseW:o}=this,i=e.factor.length,n=e.factor.angle;for(let r=0;r<e.columns;r++)for(let a=0;a<e.rows;a++)for(let l=0;l<e.layers;l++){const f=t[r][a][l];f.length=s.noise(r*i+e.offset.x,a*i+e.offset.y,l*i+e.offset.z,o),f.angle=s.noise(r*n,a*n,l*n,o)*Math.PI*2}}_drawField(e){const{field:t,options:s}=this;for(let o=0;o<s.columns;o++){const i=t[o];for(let t=0;t<s.rows;t++){const s=i[t][0],{angle:n,length:r}=s;e.setTransform(1,0,0,1,o*this.options.size,t*this.options.size),e.rotate(n),e.strokeStyle="white",e.beginPath(),e.moveTo(0,0),e.lineTo(0,this.options.size*r),e.stroke(),e.setTransform(1,0,0,1,0,0)}}}_initField(){const{columns:e,rows:t,layers:s}=this.options;this.field=new Array(e);for(let o=0;o<e;o++){this.field[o]=new Array(t);for(let e=0;e<t;e++){this.field[o][e]=new Array(s);for(let t=0;t<s;t++)this.field[o][e][t]=r.Vector.origin}}}_resetField(){const e=this.container;if(!e)return;const t=e.actualOptions.particles.move.path.options,{options:s}=this;s.width=e.canvas.size.width,s.height=e.canvas.size.height,s.size=t.size>0?t.size:l.size,s.increment=t.increment>0?t.increment:l.increment,s.draw=!!t.draw;const o=t.offset;s.offset.x=o?.x??l.offset.x,s.offset.y=o?.y??l.offset.y,s.offset.z=o?.z??l.offset.z;const i=t.factor;s.factor.angle=i?.angle??l.factor.angle,s.factor.length=i?.length??l.factor.length,s.seed=t.seed,this._simplex.seed(s.seed??(0,r.getRandom)()),s.columns=Math.floor(s.width/s.size)+1,s.rows=Math.floor(s.height/s.size)+1,s.layers=Math.floor(e.zLayers/s.size)+1,this._initField()}_setup(){this.noiseW=0,this._resetField(),addEventListener("resize",(()=>this._resetField()))}}const c="simplexNoise";async function h(e,t=!0){e.checkVersion("3.9.1"),await e.addPathGenerator(c,new f,t)}return n})()));